diff --git a/CMakeLists.txt b/CMakeLists.txt
index bb35bfee..fc840a1b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,6 +1,7 @@
 cmake_minimum_required(VERSION 2.8.12)
 project(xmrig)
 
+option(WITH_XRT             "Enable XRT support" ON)
 option(WITH_HWLOC           "Enable hwloc support" ON)
 option(WITH_CN_LITE         "Enable CryptoNight-Lite algorithms family" ON)
 option(WITH_CN_HEAVY        "Enable CryptoNight-Heavy algorithms family" ON)
@@ -143,6 +144,13 @@ if (WITH_VAES)
     endif()
 endif()
 
+if (WITH_XRT)
+	list(APPEND SOURCES_CRYPTO
+		src/backend/common/host.cpp
+	)
+#	set(XRT_LIBRARIES pthread xrt_coreutil)
+endif()
+
 if (WITH_HWLOC)
     list(APPEND HEADERS_CRYPTO
         src/crypto/common/NUMAMemoryPool.h
@@ -185,7 +193,7 @@ else()
             src/crypto/common/LinuxMemory.cpp
             )
 
-        set(EXTRA_LIBS pthread rt dl)
+        set(EXTRA_LIBS pthread rt dl uuid)
     elseif (XMRIG_OS_FREEBSD)
         set(EXTRA_LIBS kvm pthread)
     endif()
@@ -195,6 +203,7 @@ add_definitions(-DXMRIG_MINER_PROJECT -DXMRIG_JSON_SINGLE_LINE_ARRAY)
 add_definitions(-D__STDC_FORMAT_MACROS -DUNICODE -D_FILE_OFFSET_BITS=64)
 
 find_package(UV REQUIRED)
+find_package(XRT REQUIRED)
 
 include(cmake/flags.cmake)
 include(cmake/randomx.cmake)
@@ -231,13 +240,14 @@ include(src/hw/dmi/dmi.cmake)
 include_directories(src)
 include_directories(src/3rdparty)
 include_directories(${UV_INCLUDE_DIR})
+include_directories(${XRT_INCLUDE_DIR})
 
 if (WITH_DEBUG_LOG)
     add_definitions(/DAPP_DEBUG)
 endif()
 
 add_executable(${CMAKE_PROJECT_NAME} ${HEADERS} ${SOURCES} ${SOURCES_OS} ${HEADERS_CRYPTO} ${SOURCES_CRYPTO} ${SOURCES_SYSLOG} ${TLS_SOURCES} ${XMRIG_ASM_SOURCES})
-target_link_libraries(${CMAKE_PROJECT_NAME} ${XMRIG_ASM_LIBRARY} ${OPENSSL_LIBRARIES} ${UV_LIBRARIES} ${EXTRA_LIBS} ${CPUID_LIB} ${ARGON2_LIBRARY} ${ETHASH_LIBRARY} ${GHOSTRIDER_LIBRARY})
+target_link_libraries(${CMAKE_PROJECT_NAME} ${XMRIG_ASM_LIBRARY} ${OPENSSL_LIBRARIES} ${XRT_LIBRARIES} ${UV_LIBRARIES} ${EXTRA_LIBS} ${CPUID_LIB} ${ARGON2_LIBRARY} ${ETHASH_LIBRARY} ${GHOSTRIDER_LIBRARY})
 
 if (WIN32)
     add_custom_command(TARGET ${CMAKE_PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy_if_different "${CMAKE_SOURCE_DIR}/bin/WinRing0/WinRing0x64.sys" $<TARGET_FILE_DIR:${CMAKE_PROJECT_NAME}>)
diff --git a/README.md b/README.md
index 066aa0ab..5d9a359a 100644
--- a/README.md
+++ b/README.md
@@ -18,7 +18,25 @@ XMRig is a high performance, open source, cross platform RandomX, KawPow, Crypto
 * **[Binary releases](https://github.com/xmrig/xmrig/releases)**
 * **[Build from source](https://xmrig.com/docs/miner/build)**
 
+## Build
+
+We use `build_deps.sh` script to build recent versions of libuv, openssl and hwloc as static libraries.
+
+`
+1. mkdir xmrig/build && cd xmrig/scripts
+2. ./build_deps.sh && cd ../build
+3. cmake .. -DHWLOC_INCLUDE_DIR=../scripts/deps/include -DHWLOC_LIBRARY=../scripts/deps/lib/libhwloc.a -DXMRIG_DEPS=scripts/deps -DXRT_INCLUDE_DIR=/opt/xilinx/xrt/include  -DXRT_LIBRARY=$XILINX_XRT/lib/libxrt_coreutil.so
+4. make -j$(nproc)
+5. cp ../src/config.json .
+`
+
 ## Usage
+
+The algorithm of choice is `cn-heavy/xhv`.
+Change the pool address and user information
+
+Run using:
+`XCL_EMULATION_MODE=hw_emu ./xmrig`
 The preferred way to configure the miner is the [JSON config file](https://xmrig.com/docs/miner/config) as it is more flexible and human friendly. The [command line interface](https://xmrig.com/docs/miner/command-line-options) does not cover all features, such as mining profiles for different algorithms. Important options can be changed during runtime without miner restart by editing the config file or executing [API](https://xmrig.com/docs/miner/api) calls.
 
 * **[Wizard](https://xmrig.com/wizard)** helps you create initial configuration for the miner.
diff --git a/cmake/FindXRT.cmake b/cmake/FindXRT.cmake
new file mode 100644
index 00000000..9651b023
--- /dev/null
+++ b/cmake/FindXRT.cmake
@@ -0,0 +1,4 @@
+set(XRT_LIBRARIES ${XRT_LIBRARY})
+set(XRT_INCLUDE_DIRS ${XRT_INCLUDE_DIR})
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(XRT DEFAULT_MSG XRT_LIBRARY XRT_INCLUDE_DIR)
diff --git a/cmake/flags.cmake b/cmake/flags.cmake
index e9e0e395..77906f57 100644
--- a/cmake/flags.cmake
+++ b/cmake/flags.cmake
@@ -1,6 +1,6 @@
 set(CMAKE_CXX_STANDARD_REQUIRED ON)
 set(CMAKE_CXX_EXTENSIONS OFF)
-set(CMAKE_CXX_STANDARD 11)
+set(CMAKE_CXX_STANDARD 14)
 
 set(CMAKE_C_STANDARD 99)
 set(CMAKE_C_STANDARD_REQUIRED ON)
diff --git a/emconfig.json b/emconfig.json
new file mode 100644
index 00000000..acfca892
--- /dev/null
+++ b/emconfig.json
@@ -0,0 +1,153 @@
+{
+    "Comment": "This file is auto-generated by the tool. Do not modify",
+    "Version": {
+        "FileVersion": "2.0",
+        "ToolVersion": "2021.1"
+    },
+    "Platform": {
+        "Boards": [
+            {
+                "Devices": [
+                    {
+                        "Name": "xilinx_u280_xdma_201920_3",
+                        "DdrBanks": [
+                            {
+                                "Name": "dynamic_region_memory_subsystem_memory_ddr4_mem00",
+                                "Type": "ddr4",
+                                "Size": "16GB",
+                                "AXI_ARBITRATION_SCHEME": "RD_PRI_REG",
+                                "BURST_LENGTH": "8",
+                                "C0": {
+                                    "APP_ADDR_WIDTH": "31",
+                                    "APP_DATA_WIDTH": "512",
+                                    "ControllerType": "DDR4_SDRAM",
+                                    "DDR4_ADDR_WIDTH": "17",
+                                    "DDR4_AXI_ADDR_WIDTH": "34",
+                                    "DDR4_AXI_DATA_WIDTH": "512",
+                                    "DDR4_AXI_ID_WIDTH": "1",
+                                    "DDR4_AutoPrecharge": "false",
+                                    "DDR4_AxiNarrowBurst": "false",
+                                    "DDR4_BANK_GROUP_WIDTH": "2",
+                                    "DDR4_BANK_WIDTH": "2",
+                                    "DDR4_CL": "0",
+                                    "DDR4_COLUMN_WIDTH": "10",
+                                    "DDR4_CWL": "0",
+                                    "DDR4_Mem_Add_Map": "ROW_COLUMN_BANK_INTLV",
+                                    "DDR4_Ordering": "Normal",
+                                    "DDR4_RANK_WIDTH": "1",
+                                    "DDR4_ROW_WIDTH": "17",
+                                    "DDR4_tCK": "833",
+                                    "DDR4_tCKE": "0",
+                                    "DDR4_tFAW": "16",
+                                    "DDR4_tMRD": "2",
+                                    "DDR4_tRAS": "39",
+                                    "DDR4_tRCD": "17",
+                                    "DDR4_tREFI": "9363",
+                                    "DDR4_tRFC": "421",
+                                    "DDR4_tRP": "17",
+                                    "DDR4_tRRD_L": "6",
+                                    "DDR4_tRRD_S": "4",
+                                    "DDR4_tRTP": "10",
+                                    "DDR4_tWR": "19",
+                                    "DDR4_tWTR_L": "10",
+                                    "DDR4_tWTR_S": "4",
+                                    "DDR4_tXPR": "109",
+                                    "DDR4_tZQCS": "128",
+                                    "DDR4_tZQI": "0",
+                                    "DDR4_tZQINIT": "256"
+                                },
+                                "CAS_LATENCY": "17",
+                                "CAS_WRITE_LATENCY": "12",
+                                "DATA_WIDTH": "72",
+                                "MEMORY_PART": "MTA18ASF2G72PZ-2G3",
+                                "MEM_ADDR_MAP": "ROW_COLUMN_BANK_INTLV",
+                                "TIMEPERIOD_PS": "833"
+                            },
+                            {
+                                "Name": "dynamic_region_memory_subsystem_memory_ddr4_mem01",
+                                "Type": "ddr4",
+                                "Size": "16GB",
+                                "AXI_ARBITRATION_SCHEME": "RD_PRI_REG",
+                                "BURST_LENGTH": "8",
+                                "C0": {
+                                    "APP_ADDR_WIDTH": "31",
+                                    "APP_DATA_WIDTH": "512",
+                                    "ControllerType": "DDR4_SDRAM",
+                                    "DDR4_ADDR_WIDTH": "17",
+                                    "DDR4_AXI_ADDR_WIDTH": "34",
+                                    "DDR4_AXI_DATA_WIDTH": "512",
+                                    "DDR4_AXI_ID_WIDTH": "1",
+                                    "DDR4_AutoPrecharge": "false",
+                                    "DDR4_AxiNarrowBurst": "false",
+                                    "DDR4_BANK_GROUP_WIDTH": "2",
+                                    "DDR4_BANK_WIDTH": "2",
+                                    "DDR4_CL": "0",
+                                    "DDR4_COLUMN_WIDTH": "10",
+                                    "DDR4_CWL": "0",
+                                    "DDR4_Mem_Add_Map": "ROW_COLUMN_BANK_INTLV",
+                                    "DDR4_Ordering": "Normal",
+                                    "DDR4_RANK_WIDTH": "1",
+                                    "DDR4_ROW_WIDTH": "17",
+                                    "DDR4_tCK": "833",
+                                    "DDR4_tCKE": "0",
+                                    "DDR4_tFAW": "16",
+                                    "DDR4_tMRD": "2",
+                                    "DDR4_tRAS": "39",
+                                    "DDR4_tRCD": "17",
+                                    "DDR4_tREFI": "9363",
+                                    "DDR4_tRFC": "421",
+                                    "DDR4_tRP": "17",
+                                    "DDR4_tRRD_L": "6",
+                                    "DDR4_tRRD_S": "4",
+                                    "DDR4_tRTP": "10",
+                                    "DDR4_tWR": "19",
+                                    "DDR4_tWTR_L": "10",
+                                    "DDR4_tWTR_S": "4",
+                                    "DDR4_tXPR": "109",
+                                    "DDR4_tZQCS": "128",
+                                    "DDR4_tZQI": "0",
+                                    "DDR4_tZQINIT": "256"
+                                },
+                                "CAS_LATENCY": "17",
+                                "CAS_WRITE_LATENCY": "12",
+                                "DATA_WIDTH": "72",
+                                "MEMORY_PART": "MTA18ASF2G72PZ-2G3",
+                                "MEM_ADDR_MAP": "ROW_COLUMN_BANK_INTLV",
+                                "TIMEPERIOD_PS": "833"
+                            }
+                        ],
+                        "FeatureRom": {
+                            "Major_Version": "10",
+                            "Minor_Version": "1",
+                            "Vivado_Build_Id": "2742762",
+                            "Ip_Build_Id": "2719198",
+                            "Time_Since_Epoch": "1579649056",
+                            "Fpga_Part_Name": "xcu280-fsvh2892-2L-e",
+                            "Vbnv_Name": "xilinx_u280_xdma_201920_3",
+                            "Ddr_Channel_Count": "2",
+                            "Ddr_Channel_Size": "16",
+                            "Dr_Base_Address": "0",
+                            "Feature_Bitmap": "197133",
+                            "Uuid": "f2b82d53-372f-45a4-bbe9-3d1c980216da",
+                            "Unified_Platform": "enabled",
+                            "Aurora_Link": "disabled",
+                            "Board_Mgmt": "enabled",
+                            "Board_Scheduler": "enabled",
+                            "Prom_Type": "0x0",
+                            "Debug_Type": "0x2",
+                            "Peer_To_Peer": "enabled",
+                            "Cdma_Size": "4",
+                            "Cdma_Base_Address0": "0",
+                            "Cdma_Base_Address1": "0",
+                            "Cdma_Base_Address2": "0",
+                            "Cdma_Base_Address3": "0"
+                        }
+                    }
+                ],
+                "NumBoards": "1"
+            }
+        ],
+        "UnifiedPlatform": "true",
+        "ExpandedPR": "false"
+    }
+}
diff --git a/src/backend/common/common.cmake b/src/backend/common/common.cmake
index 52a5ee6f..0198e6aa 100644
--- a/src/backend/common/common.cmake
+++ b/src/backend/common/common.cmake
@@ -18,6 +18,7 @@ set(SOURCES_BACKEND_COMMON
     src/backend/common/Threads.cpp
     src/backend/common/Worker.cpp
     src/backend/common/Workers.cpp
+    src/backend/common/host.cpp
    )
 
 if (WITH_RANDOMX AND WITH_BENCHMARK)
diff --git a/src/backend/common/host.cpp b/src/backend/common/host.cpp
new file mode 100644
index 00000000..3086aff3
--- /dev/null
+++ b/src/backend/common/host.cpp
@@ -0,0 +1,124 @@
+/**
+* Copyright (C) 2019-2021 Xilinx, Inc
+*
+* Licensed under the Apache License, Version 2.0 (the "License"). You may
+* not use this file except in compliance with the License. A copy of the
+* License is located at
+*
+*     http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+* License for the specific language governing permissions and limitations
+* under the License.
+*/
+
+#include <iostream>
+#include <cstring>
+
+// XRT includes
+#include "experimental/xrt_bo.h"
+#include "experimental/xrt_ip.h"
+#include "experimental/xrt_device.h"
+#include "experimental/xrt_kernel.h"
+#include "experimental/xrt_xclbin.h"
+#include "backend/common/host.h"
+
+#define IP_START 0x1
+#define IP_IDLE 0x4
+#define CSR_OFFSET 0x0
+#define DATA_SIZE 256
+
+#define deb 0
+
+xmrig::XRTHost::XRTHost(){
+	printf("\nSetting up XRTHost connection.. \n");
+
+	//TODO: hardcoded for testing, this will change
+	std::string binaryFile = "./../xcl/xrt_test.xclbin";
+	int device_index = 0;
+
+
+	std::cout << "Open the device" << device_index << std::endl;
+	xmrig::XRTHost::device = xrt::device(device_index);
+	std::cout << "Load the xclbin " << binaryFile << std::endl;
+	auto uuid = device.load_xclbin(binaryFile);
+	xmrig::XRTHost::ip = xrt::ip(device, uuid, "krnl_cryptonight_rtl");
+	xmrig::XRTHost::xclbin = xrt::xclbin(binaryFile);
+}
+
+xmrig::XRTHost::~XRTHost(){
+}
+
+
+int xmrig::XRTHost::callXRTHost(const uint8_t *__restrict__ blck_hdr, size_t size, uint8_t *__restrict__ output, uint32_t output_nonce, const uint64_t target, const uint32_t nonce) {
+
+    size_t vector_size_bytes = sizeof(int) * DATA_SIZE;
+
+    xrt::xclbin::kernel kernel_used;
+
+    std::vector<xrt::xclbin::ip> cu;
+    auto ip =  xmrig::XRTHost::ip ;
+    auto xclbin = xmrig::XRTHost::xclbin;
+    for (auto& kernel : xclbin.get_kernels()) {
+        if (kernel.get_name() == "krnl_cryptonight_rtl") {
+            cu = kernel.get_cus();
+        }
+    }
+
+    if (cu.empty()) throw std::runtime_error("IP krnl_cryptonight_rtl not found in the provided xclbin");
+
+
+    if(deb){
+	    printf("\n This is the blck_hdr: = %08lx %016lx\n",(uint32_t*)target, nonce);
+	    for (size_t i = 0; i < size/4; i++) {
+           printf("%08lx ", ((uint32_t *) blck_hdr)[i]);
+        }
+    }
+
+
+    auto args = cu[0].get_args();
+    int reg_size= size/4;
+
+    //full block header to the hw
+    if(deb)std::cout << "Setting the Register for \"full block_header\" " << std::endl;
+    for (size_t i = 0; i < size/4; i++)
+	ip.write_register(args[i].get_offset(), ((uint32_t *) blck_hdr)[i]);
+
+
+    //set the initial nonce
+    if(deb)std::cout << "Setting the Register for \"nonce\"" << std::endl;
+    ip.write_register(args[reg_size+1].get_offset(), nonce);
+
+    //target
+    if(deb)std::cout << "Setting the Register for \"target\" " << std::hex << (uint32_t)target << std::endl;
+    ip.write_register(args[reg_size+2].get_offset(), (uint32_t)target);
+
+
+    uint32_t axi_ctrl = 0;
+
+    //IP start
+    if(deb)std::cout << "INFO: IP Start" << std::endl;
+    axi_ctrl = IP_START;
+    ip.write_register(CSR_OFFSET, axi_ctrl);
+
+    // Wait until the IP is DONE
+    axi_ctrl = 0;
+    while ((axi_ctrl & IP_IDLE) != IP_IDLE) {
+        axi_ctrl = ip.read_register(CSR_OFFSET);
+    }
+
+    if(deb)std::cout << "INFO: IP Done" << std::endl;
+
+    // Get the output nonce value
+    if(deb)std::cout << "Read the winning nonce from the device" << std::endl;
+    output_nonce = (uint32_t)ip.read_register(args[reg_size+3].get_offset());
+
+    if(deb)std::cout << "Read the final hash output" << std::endl;
+    output = (uint8_t*)ip.read_register(args[reg_size+4].get_offset());
+
+    if(deb)std::cout << std::hex << " output nonce" << output_nonce<< std::endl;
+
+    return 0;
+}
diff --git a/src/backend/common/host.h b/src/backend/common/host.h
new file mode 100644
index 00000000..47cfc361
--- /dev/null
+++ b/src/backend/common/host.h
@@ -0,0 +1,51 @@
+/* XMRig
+ * Copyright (c) 2017-2018 XMR-Stak    <https://github.com/fireice-uk>, <https://github.com/psychocrypt>
+ * Copyright (c) 2018-2020 SChernykh   <https://github.com/SChernykh>
+ * Copyright (c) 2016-2020 XMRig       <https://github.com/xmrig>, <support@xmrig.com>
+ *
+ *   This program is free software: you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, either version 3 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef XMRIG_HOST_H
+#define XMRIG_HOST_H
+
+
+#include <cmath>
+#include <cstddef>
+#include <cstdint>
+
+#include "experimental/xrt_bo.h"
+#include "experimental/xrt_device.h"
+#include "experimental/xrt_kernel.h"
+#include "experimental/xrt_ip.h"
+#include "experimental/xrt_xclbin.h"
+
+namespace xmrig {
+
+class XRTHost
+{
+    xrt::device device;
+    xrt::ip ip;
+    xrt::xclbin xclbin;
+public:
+    XRTHost();
+    int callXRTHost(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, uint32_t output_nonce, const uint64_t target, const uint32_t nonce); //, const char* str = __builtin_FUNCTION());
+    ~XRTHost();
+};
+
+
+} // namespace xmrig
+
+
+#endif /* XMRIG_HOST_H */
diff --git a/src/backend/cpu/CpuWorker.cpp b/src/backend/cpu/CpuWorker.cpp
index 86201e50..c29211f1 100644
--- a/src/backend/cpu/CpuWorker.cpp
+++ b/src/backend/cpu/CpuWorker.cpp
@@ -16,6 +16,7 @@
  *   along with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <iostream>
 #include <cassert>
 #include <thread>
 #include <mutex>
@@ -25,6 +26,7 @@
 #include "backend/cpu/CpuWorker.h"
 #include "base/tools/Alignment.h"
 #include "base/tools/Chrono.h"
+#include "base/tools/BenchmarkTimer.h"
 #include "core/config/Config.h"
 #include "core/Miner.h"
 #include "crypto/cn/CnCtx.h"
@@ -38,6 +40,8 @@
 #include "crypto/ghostrider/ghostrider.h"
 #include "net/JobResults.h"
 
+//for xrt host
+#include "backend/common/host.h"
 
 #ifdef XMRIG_ALGO_RANDOMX
 #   include "crypto/randomx/randomx.h"
@@ -53,6 +57,8 @@
 #   include "backend/common/benchmark/BenchState.h"
 #endif
 
+#define timehash 0
+#define enableXRT 1
 
 namespace xmrig {
 
@@ -244,6 +250,13 @@ void xmrig::CpuWorker<N>::hashrateData(uint64_t &hashCount, uint64_t &, uint64_t
 template<size_t N>
 void xmrig::CpuWorker<N>::start()
 {
+    //for benchmarking
+    struct timespec tstart, tend;
+
+
+    //calling the host function from xmrig
+    xmrig::XRTHost host;
+    uint32_t output_nonce;
     while (Nonce::sequence(Nonce::CPU) > 0) {
         if (Nonce::isPaused()) {
             do {
@@ -337,8 +350,15 @@ void xmrig::CpuWorker<N>::start()
                     break;
 #               endif
 
-                default:
-                    fn(job.algorithm())(m_job.blob(), job.size(), m_hash, m_ctx, job.height());
+            default:{
+				//calling the host function from xmrig
+				if (timehash) clock_gettime(CLOCK_MONOTONIC, &tstart);
+				if (enableXRT) host.callXRTHost(m_job.blob(), job.size(), m_hash, output_nonce, job.target(), *m_job.nonce(1));
+				else fn(job.algorithm())(m_job.blob(), job.size(), m_hash, m_ctx, job.height());
+
+				if (timehash)clock_gettime(CLOCK_MONOTONIC, &tend);
+				if (timehash)printf("cryptonight_single_hash %lld mus \n", (long long) xmrig::time_diff_mus(tstart, tend));
+		    }
                     break;
                 }
 
@@ -360,7 +380,9 @@ void xmrig::CpuWorker<N>::start()
                     else
 #                   endif
                     if (value < job.target()) {
-                        JobResults::submit(job, current_job_nonces[i], m_hash + (i * 32), job.hasMinerSignature() ? miner_signature_saved : nullptr);
+			//submit value
+			if (enableXRT)JobResults::submit(job, output_nonce, m_hash + (i * 32), job.hasMinerSignature() ? miner_signature_saved : nullptr);
+			else JobResults::submit(job, current_job_nonces[i], m_hash + (i * 32), job.hasMinerSignature() ? miner_signature_saved : nullptr);
                     }
                 }
                 m_count += N;
diff --git a/src/base/base.cmake b/src/base/base.cmake
index 0f4f8725..5fb6e868 100644
--- a/src/base/base.cmake
+++ b/src/base/base.cmake
@@ -85,6 +85,7 @@ set(HEADERS_BASE
     src/base/tools/Span.h
     src/base/tools/String.h
     src/base/tools/Timer.h
+    src/base/tools/BenchmarkTimer.h
    )
 
 set(SOURCES_BASE
diff --git a/src/base/tools/BenchmarkTimer.h b/src/base/tools/BenchmarkTimer.h
new file mode 100644
index 00000000..c980f99b
--- /dev/null
+++ b/src/base/tools/BenchmarkTimer.h
@@ -0,0 +1,48 @@
+#ifndef XMRIG_BENCHMARKTIMER_H
+#define XMRIG_BENCHMARKTIMER_H
+
+
+#include <cstdint>
+#include <iostream>
+#include <time.h>
+#include <stdlib.h>
+#include <ctime>
+#include <unistd.h>
+#include <cerrno>
+
+
+namespace xmrig {
+
+inline double time_diff_mus(struct timespec start, struct timespec end){
+    double timespan;
+    if ((end.tv_nsec-start.tv_nsec)<0) {
+        timespan  = (end.tv_sec -start.tv_sec  - 1)*1.0e3 ;
+        timespan += (end.tv_nsec-start.tv_nsec + 1000000000UL)*1.0e-6;
+    } else {
+        timespan  = (end.tv_sec - start.tv_sec)*1.0e3 ;
+        timespan += (end.tv_nsec-start.tv_nsec )*1.0e-3;
+    }
+    return timespan;
+
+}
+
+inline double time_diff_ms(struct timespec start, struct timespec end){
+    double timespan;
+    if ((end.tv_nsec-start.tv_nsec)<0) {
+        timespan  = (end.tv_sec -start.tv_sec  - 1)*1.0e3 ;
+        timespan += (end.tv_nsec-start.tv_nsec + 1000000000UL)*1.0e-6;
+    } else {
+        timespan  = (end.tv_sec - start.tv_sec)*1.0e3 ;
+        timespan += (end.tv_nsec-start.tv_nsec )*1.0e-6;
+    }
+    return timespan;
+
+}
+
+
+}
+
+/* namespace xmrig */
+
+
+#endif /* XMRIG_BENCHMARKTIMER_H */
diff --git a/src/crypto/cn/CryptoNight_x86.h b/src/crypto/cn/CryptoNight_x86.h
index 434c7363..1bcd931f 100644
--- a/src/crypto/cn/CryptoNight_x86.h
+++ b/src/crypto/cn/CryptoNight_x86.h
@@ -42,6 +42,7 @@
 #include "crypto/cn/CryptoNight.h"
 #include "crypto/cn/soft_aes.h"
 
+#include "base/tools/BenchmarkTimer.h"
 
 #ifdef XMRIG_VAES
 #   include "crypto/cn/CryptoNight_x86_vaes.h"
@@ -56,6 +57,13 @@ extern "C"
 #include "crypto/cn/c_skein.h"
 }
 
+//enable below for printing function timing
+#define timeimplode 0
+#define timeexplode 0
+#define timekeccak 0
+#define timekeccakf 0
+#define timeothers 0
+#define timeextra 0
 
 static inline void do_blake_hash(const uint8_t *input, size_t len, uint8_t *output) {
     blake256_hash(output, input, len);
@@ -642,6 +650,8 @@ static void cryptonight_single_hash_gr_sse41(const uint8_t* __restrict__ input,
 template<Algorithm::Id ALGO, bool SOFT_AES, int interleave>
 inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t size, uint8_t *__restrict__ output, cryptonight_ctx **__restrict__ ctx, uint64_t height)
 {
+    //for benchmarking
+    struct timespec tstart, tend;
 #   ifdef XMRIG_FEATURE_ASM
     if (!SOFT_AES) {
         switch (ALGO) {
@@ -678,12 +688,21 @@ inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t si
         return;
     }
 
+    if (timekeccak)clock_gettime(CLOCK_MONOTONIC, &tstart);
     keccak(input, size, ctx[0]->state);
+    if (timekeccak)clock_gettime(CLOCK_MONOTONIC, &tend);
+    if (timekeccak)printf("keccak %lld mus \n", (long long) xmrig::time_diff_mus(tstart, tend));
 
     if (props.half_mem()) {
         ctx[0]->first_half = true;
     }
+
+    if (timeexplode)clock_gettime(CLOCK_MONOTONIC, &tstart);
     cn_explode_scratchpad<ALGO, SOFT_AES, interleave>(ctx[0]);
+    if (timeexplode)clock_gettime(CLOCK_MONOTONIC, &tend);
+    if (timeexplode)printf("cn_explode_scratchpad %lld mus \n", (long long) xmrig::time_diff_mus(tstart, tend));
+
+    if (timeothers)clock_gettime(CLOCK_MONOTONIC, &tstart);
 
     uint64_t *h0 = reinterpret_cast<uint64_t*>(ctx[0]->state);
     uint8_t *l0   = ctx[0]->memory;
@@ -838,9 +857,24 @@ inline void cryptonight_single_hash(const uint8_t *__restrict__ input, size_t si
     }
 #   endif
 
+
+    if (timeothers)clock_gettime(CLOCK_MONOTONIC, &tend);
+    if (timeothers)printf("others %lld ms \n", (long long) xmrig::time_diff_mus(tstart, tend));
+
+    if (timeimplode)clock_gettime(CLOCK_MONOTONIC, &tstart);
     cn_implode_scratchpad<ALGO, SOFT_AES, interleave>(ctx[0]);
+    if (timeimplode)clock_gettime(CLOCK_MONOTONIC, &tend);
+    if (timeimplode)printf("cn_implode_scratchpad %lld mus \n", (long long) xmrig::time_diff_mus(tstart, tend));
+
+    if (timekeccakf)clock_gettime(CLOCK_MONOTONIC, &tstart);
     keccakf(h0, 24);
+    if (timekeccakf)clock_gettime(CLOCK_MONOTONIC, &tend);
+    if (timekeccakf)printf("keccakf %lld mus \n", (long long) xmrig::time_diff_mus(tstart, tend));
+
+    if (timeextra)clock_gettime(CLOCK_MONOTONIC, &tstart);
     extra_hashes[ctx[0]->state[0] & 3](ctx[0]->state, 200, output);
+    if (timeextra)clock_gettime(CLOCK_MONOTONIC, &tend);
+    if (timeextra)printf("extra_hashes %lld ms \n", (long long) xmrig::time_diff_mus(tstart, tend));
 }
 
 

